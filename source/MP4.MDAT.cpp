/*******************************************************************************
 * Copyright (c) 2011, Jean-David Gadina - www.xs-labs.com
 * Distributed under the Boost Software License, Version 1.0.
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 ******************************************************************************/
 
/* $Id$ */

#include "MP4.MDAT.h"

using namespace MP4;

const int MDAT::m_kSampleRates[] = { 96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350 };

MDAT::MDAT( void )
{
    this->_type.append( "MDAT" );
    _stream = NULL;
    _length = 0;

    m_initialised = false;
    m_dataOffset = 0;
    m_sampleSizes = NULL;
    m_sampleTimes = NULL;
    m_aot = 0;
    m_sampleRate = 0;
    m_channelConfig = 0;
    m_sampleIdx = 0;
}

std::string MDAT::description( void )
{
    std::ostringstream o;
    
    o << "MP4 Atom:           " << this->_type << "\n";
    
    return o.str();
}

void MDAT::processData( MP4::BinaryStream * stream, size_t length )
{
    _stream = stream;
    _length = length;

    stream->ignore( length );
}

bool MDAT::initialiseAACGenerator( uint32_t dataOffset, std::vector< uint32_t > *sampleSizes, TimeData *sampleTimes,
                                   uint32_t aot, uint32_t sampleRate, uint32_t channelConfig )
{
    if ( _length == 0 || _stream == NULL )
    {
        return false;
    }

    if ( !m_initialised )
    {
        m_initialised = true;
    }

    //set the stream to good state and seek to where the data is in stream
    _stream->clear();
    _stream->seekg( dataOffset );

    m_dataOffset    = dataOffset;
    m_sampleSizes   = sampleSizes;
    m_sampleTimes   = sampleTimes;
    m_aot           = aot;
    m_sampleRate    = sampleRate;
    m_channelConfig = channelConfig;
    m_sampleIdx     = 0;

    return true;
}

bool MDAT::generateAACFrame( char *frameOut )
{
  if ( !m_initialised )
  {
      return false;
  }

  if ( m_sampleIdx >= m_sampleSizes->size() )
  {
      return false;
  }

  uint32_t nextSample = m_sampleSizes->at( m_sampleIdx++ );
  _stream->read( frameOut + 7, nextSample );
  generateADTS( frameOut, nextSample, m_aot, m_sampleRate, m_channelConfig );

  return !this->_stream->eof();
}

void MDAT::generateADTS( char *adtsHeader, uint64_t sampleSize, uint32_t aot, uint32_t sampleRate, uint32_t channelConfig ) const
{
    uint64_t ADTS = 0;                              // Using lowest 56 bits
    ADTS |= ( (uint64_t)0xFFF << 44 );              // First 12 bits (syncword)
                                                    // 13th - 15th bits (MPEG4/Layer left as 0)
    ADTS |= ( (uint64_t)1 << 40 );                  // 16th bit (CRC flag)
    ADTS |= ( (uint64_t)(aot - 1) << 38 );          // 17th & 18th bits (AOT minus 1)
    ADTS |= ( (uint64_t)sampleRate << 34 );         // 19th - 22nd bits (Sample rate)
                                                    // 23rd bit (Private bit left as 0)
    ADTS |= ( (uint64_t)channelConfig << 30 );      // 24th - 26th bits (Channel config)
                                                    // 27th - 30th bits (Originality/Home/Copyrighted/Copyright bit left as 0)
    ADTS |= ( (uint64_t)((7 + sampleSize) << 13) ); // 31st - 43rd bits (Frame size + header size 7)
    ADTS |= ( (uint64_t)0x7FF << 2 );               // 44th - 54th bits (Buffer fullness)
    //ADTS |= ( (uint64_t)0 );                      // 55th - 56th bits (Frames per ADTS minus 1)

    memset( adtsHeader, 0, 7 );
    for ( int c = 0; c < 7; ++c )
    {
        uint64_t mask = ( (uint64_t)0xFF << (c * 8) );
        adtsHeader[ 6 - c ] = (char)( (ADTS & mask) >> (c * 8) );
    }
}

bool MDAT::seek( int offsetSeconds, int sampleRate )
{
    if ( !m_initialised )
    {
        return false;
    }

    double timeCount = 0.0;
    uint32_t sampleIdx = 0;
    for ( size_t t = 0; t < m_sampleTimes->size(); ++t )
    {
        uint32_t timeDuplicates = m_sampleTimes->at( t ).first;
        uint32_t timeDelta = m_sampleTimes->at( t ).second;
        for ( uint32_t d = 0; d < timeDuplicates; ++d )
        {
            double nextTime = timeDelta / (double)sampleRate;
            timeCount += nextTime;
            sampleIdx++;
            if ( timeCount > offsetSeconds )
            {
                return seekAACFrame( sampleIdx );
            }
        }
    }

    return false;
}

bool MDAT::seekAACFrame( uint32_t sampleIdx )
{
  if ( !m_initialised )
  {
      return false;
  }

  if ( sampleIdx >= m_sampleSizes->size() )
  {
      return false;
  }

  //reset stream to beginning
  _stream->clear();
  _stream->seekg( m_dataOffset );
  m_sampleIdx = 0;

  //skip frames until we find our sampleIdx
  while ( m_sampleIdx < sampleIdx )
  {
      uint32_t nextSample = m_sampleSizes->at( m_sampleIdx++ );
      _stream->ignore( nextSample );
  }

  return !this->_stream->eof();
}
