/*******************************************************************************
 * Copyright (c) 2011, Jean-David Gadina - www.xs-labs.com
 * Distributed under the Boost Software License, Version 1.0.
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 ******************************************************************************/
 
/* $Id$ */

#include "MP4.STSD.h"

using namespace MP4;
          
STSD::STSD( void )
{
    this->_type.append( "STSD" );
    m_valid = true;
}

std::string STSD::description( void )
{
    std::ostringstream o;
    
    o << "MP4 Atom:           " << this->_type << "\n";
    
    return o.str();
}

void STSD::processData( MP4::BinaryStream * stream, size_t length )
{
    (void)length;
    stream->ignore( 4 );
    m_valid &= stream->readBigEndianUnsignedInteger() == 1;

    stream->ignore( 4 );
    m_valid &= readBoxType( stream, "mp4a" );
    stream->ignore( 32 );
    m_valid &= readBoxType( stream, "esds" );
    stream->ignore( 4 );

    uint32_t padding = 0;
    int32_t descLength = readTagLength( stream, 0x03, padding );  //ES tag 0x03
    m_valid &= ( descLength != -1 );

    stream->ignore( 3 );
    m_valid &= ( readTagLength( stream, 0x04, padding ) != -1 );  //DecoderConfig 0x04
    descLength -= padding;

    m_valid &= ( stream->readUnsignedChar() == 0x40 );            //MPEG4 0x40
    m_valid &= ( stream->readUnsignedChar() == 0x15 );            //Audio stream 0x15
    stream->ignore( 11 );

    m_valid &= ( readTagLength( stream, 0x05, padding ) != -1 );  //DecoderSpecific 0x05
    descLength -= padding;

    uint16_t encFlags = stream->readBigEndianUnsignedShort();
    m_aot = ( encFlags & 0xF800 ) >> 11;
    m_sampleRate = ( encFlags & 0x780 ) >> 7;
    m_channelConfig = ( encFlags & 0x78 ) >> 3;

    stream->ignore( descLength - 22 );
}

int32_t STSD::readTagLength( MP4::BinaryStream * stream, uint8_t tag, uint32_t &paddingOut )
{
    uint8_t readTag = stream->readUnsignedChar();
    if ( readTag != tag )
    {
        std::cout << "[STSD] 0x0" << (uint32_t)tag << " not read" << std::endl;
        std::cout << "[STSD] 0x0" << (uint32_t)readTag << " was read instead" << std::endl;
        return -1;
    }
    uint8_t tagLen = 0;
    paddingOut = -1;
    do
    {
        tagLen = stream->readUnsignedChar();
        paddingOut++;
    }
    while ( tagLen == 0x80 );

    return (int32_t)tagLen;
}

bool STSD::readBoxType( MP4::BinaryStream * stream, std::string name )
{
    char type[ 5 ];
    stream->read( type, 4 );
    type[ 4 ] = '\0';
    std::string readName( type );

    std::transform( name.begin(), name.end(), name.begin(), ::tolower );
    std::transform( readName.begin(), readName.end(), readName.begin(), ::tolower );

    return name == readName;
}
